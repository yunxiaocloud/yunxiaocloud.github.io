---
layout: post
title: '来自阿里的iOS面试题'
subtitle: '来来来,查缺补漏啦'
date: 2017-11-06
categories: 技术
cover: 'http://bpic.588ku.com/back_pic/00/08/53/17562a43dac4e41.jpg!/fh/300/quality/90/unsharp/true/compress/true'
tags: iOS 安卓 客户端
---
## 寄语
#### 很多时候,我们看待技术的方向总是以目前所处的环境,或者项目.但我们应该意识到,我们是以开发者自居,而不是某某公司的开发者自居.我们学习的储备技术应该从自身出发.让自己技术范畴的选择更加宽阔,而不是随着经验的累计反而变得更加狭隘,缺少了创造性和选择性.我们是独一无二的,我们应该做独一无二的事!用全力以赴的态度去追逐,你会发现那些曾经你偷偷设想的事正一步一步朝你走来.人最珍贵的就是我们的思想,去开拓的思考,像守护生命一样,守护你坚守的梦想.

# 阿里iOS面试题
1. dSYM你是如何分析的?
2. 多线程有哪几种?你更倾向与哪一种?
3. 单例弊端?
4. 介绍下App启动的完成过程?
5. 比如App启动过慢,你可能想到的因素有哪些?
6. 0x8badfood表示是什么?
7. 怎么防止反编译?
8. 说说你了解的第三方原理或底层知识

### 1.dSYM你是如何分析的?
### dSYM是什么?
Xcode编译项目后,我们会看到一个同名的dSYM文件,dSYM是保存16进制函数地址映射信息的中转文件,我们调试的symbols都会包含在这个文件中,并且每次编译项目的时候都会生成一个新的dSYM文件,位于/Users/<用户名>/Library/Developer/Xcode/Archives目录下,对于每一个发布版本我们都很有必要保存对应的Archives文件.
### dSYM文件有什么用?
当我们软件release模式打包或上线后,不会像我们在Xcode中那样直观的看到崩溃的错误,这是时候我们就需要分析crash report文件,iOS设备中会有日志文件保存我们每个应用出错的函数内存地址,通过Xcode 的Organizer可以将iOS设备中的DeviceLog导出成crash文件,这个时候我们就可以通过出错的函数地址去查询dSYM文件中程序对应的函数名和文件名.大前提是我们需要有软件版本对应的dSYM文件,这也是为什么我们很有必要保存每个发布版本的Archives文件了.
### 如何将文件--对应?
每一个xx.app和xx.app.dSYM文件都有对应的UUID,crash文件也有自己的UUID,只要这三个文件的UUID一致,我们就可以通过解析出正确的错误函数信息了. 1.查看xx.app文件的UUID,termianl输入命令:dwarfdump --uuid xx.app/xx(xx代表你的项目名) 2.查看xx.app.dSYM文件的UUID,在termainal输入命名: dwarfdump --uuid xx.app.dSYM 3.crash 文件内第一行 Incident Identifier 就是该crash 文件的UUID.

### dSYM 工具
### 将命令封装到应用,在解决bug上提供了便利
使用步骤:1.将打包发布软件时的xcarchive文件拖入软件窗口内的任意位置(支持多个文件同时拖入,注意: 文件名不要包含空格)2.选中任意一个版本的xcarchive文件,右边会列出该xcarchive文件支持的CPU类型,选中错误对应的CPU类型. 3.对比错误给出的UUID和工具界面中给出的UUID是否一致. 4.将错误地址输入工具的文本框中,点击分析.

## 2.多线程有哪几种?你更倾向哪一种?
### 1.多线程分类
* pthread
 1. 一套通用的多线程API   
 2. 适用于Unix\Linux\Windows等系统 
 3. 跨平台.可移植
 4. 使用难度大
 5. 使用语言:C语言
 6. 使用频率:几乎不适用
 7. 线程生命周期:由开发者进行管理
* NSThread
 1. 面向对象
 2. 简单易用,可直接操作线程
 3. 使用语言:OC语言
 4. 使用频率:偶尔使用
 5. 线程生命周期: 有开发者管理
* GCD
 1. 替换NSThread等线程技术
 2. 充分利用率设备多核(自动)
 3. 使用语言: C语言
 4. 使用频率: 经常使用
 5. 线程生命周期: 自动管理
* NSOperation
 1. 基于GCD(底层是GCD)
 2. 比GCD多了一些更简单使用的功能
 3. 使用更加面向对象
 4. 使用语言:OC语言
 5. 使用频率:经常使用
 6. 线程生命周期: 自动管理

#### 多线程原理:
同一时间,CPU只能处理1条线程,只有1条线程在工作(执行)多线程并发(同时)执行,其实是CPU快速的在多条线程之前调度(切换)如果CPU调度线程的时间足够快,就造成了多线程并发执行的假象.思考:如果线程非常非常多,会发生什么情况?CPU会在N多线程之间调度,CPU会累死,消耗大量的CPU资源每条线程别调度执行的频次会降低(线程执行效率降低)

#### 多线程的优点:
能适当提高程序的执行效率,能适当提高资源利用率(CPU,内存利用率)

#### 多线程的缺点:
线程需要占用一定的内存空间(默认情况下,主线程占用1M,子线程占用512KB),如果开启大量的线程,会占用大量的内存空间,降低程序的性能,线程越多,CPU在调度线程上的开销就越大.程序设计更加复杂:比如线程之间的通信、多线程的数据共享.

### 2.你更倾向于哪一种? 倾向于GCD
GCD技术是一个轻量的,底层实现隐藏的神奇技术,我们能够通过GCD和block轻松实现多线程编程,有时候,GCD相比其他系统提供的多线程方法更加有效,当然,有时候GCD不是最佳选择,另一个多线程编程的技术NSOpreationQueue让我们能够将后台线程以队列方式依序执行,并提供更多操作的入口,这和GCD的实现有些类似.这种类似不是一个巧合,在早期,MacOS与iOS的程序都普遍采用Operation Queue 来进行编写后天线程代码,而之后出现的GCD技术大体是依照前者的原则来实现的,而随着GCD的普及,在iOS 4与MacOSX 10.6以后,Operation Queue的底层实现都是用GCD来实现的

### 那这两者之间有什么区别呢?
1. GCD是底层的C语言构成的API,而NSOperationQueue及相关对象是Objc的对象.在GCD中,在队列中执行的是由block构成的任务,这是一个轻量级的数据结构;而Operation作为一个对象,为我们提供了更多的选择
2. 在NSOperationQueue中,我们可以随时取消已经设定要准备执行的任务(当然,已经开始任务就无法阻止了),而GCD没法停止已经加入queue的block(其实是有的,但需要许多复杂的代码)
3. NSOperation能够方便的设置依赖关系,我们可以让一个Operation依赖于另一个Operation,这样的话尽管两个Operation处于同一个并行队列中,但前者会直到后者执行完毕后再执行.
4. 我们能将KVO应用在NSOperation中,可以监听一个Operation是否完成或取消,这样子能比GCD更加有效的掌控我们执行的后台任务.
5. 在NSOperation中,我们能够设置NSOperation的priority优先级,能够使同一个并行队列中任务区分先后的执行,而在GCD中,我们只能区分不同任务队列的优先级,也需要大量的复杂代码.
6. 我们能够对NSOperation进行继承,在这之上添加成语变量与成员方法,提高整个代码的复用度,这比简单的将block任务排入执行队列更有自由度,能够在其之上添加更多自定制的功能.总的来说,Operation queue提供了更多你在编写多线程程序是需要的功能,并隐藏了许多线程调度,线程取消与线程优先级的复杂代码,为我们提供简单的API入口.从编程原则来说,一般我们需要尽可能的使用高等级,封装完美的API,在必须时才使用底层API.但是我认为当我们的需求能够以更简单的底层代码完成的时候,简洁的GCD或许是个更好的选择,而Operation queue 为我们提供更多的选择.

### 3.你更倾向于哪一种? 倾向于NSOperation
1. NSOperation拥有更多的函数可用,具体查看api. NSOperationQueue是在GCD基础上实现的,只不过是GCD更高一层的抽象.
2. 在NSOperationQueue中,可以建立各个NSOperation之间的依赖关系.
3. NSOperationQueue支持KVO.可以监测Operation是否正在执行(isExecuted)、是否结束(isFinished)、是否取消(isCanceled)
4. GCD只支持FIFO的队列,而NSOperationQueue可以调整对垒的执行顺序(通过调整权重).NSOperationQueue可以方便的管理并发,NSOperation之间的优先级.使用NSOperation的情况:各个操作之间有依赖关系,操作需要取消,暂停,并发管理,控制操作之间优先级,限制同时能执行的线程数量.让线程在某时刻停止/继续等.  使用GCD的情况: 一般的需求很简单的多线程操作,用GCD就可以了,简单高效.从编程原则来说,一般我们需要尽可能的使用高等级,封装完美的API,在必须时才使用底层API.当需求简单,简洁的GCD或许是个更好的选择,而Operation queue为我们提供更多的选择.

## 3.单例弊端
#### 优点:
1. 一个类只能被实例化一次,提供了对唯一实例的受控访问.
2. 节省系统资源
3. 允许可变数目的实例

#### 缺点:
1. 一个类只有一个对象,可能造成责任过重,在一定程度上违背了"单一职责原则"
2. 由于单例模式中没有抽象层,因此单例类的扩展有很大的困难.
3. 滥用单例将带来一些负面问题,如为了节省资源将数据库连接池对象设置的单例类,可能会导致共享连接池对象的程序过多而出现连接池溢出;如果实例化的对象长时间不被利用,系统会认为是垃圾而被回收,这将导致对象状态的丢失.

## 4.APP启动的完整过程
1. APP启动过程
 * 解析Info.plist
 * 加载相关信息,例如闪屏
 * 沙盒建立,权限检查
 * Mach-O加载
 * 如果是二进制文件,寻找合适当前CPU类别的部分
 * 加载所有依赖的Mach-O文件(递归调用Mach-O加载方法)
 * 定位内部,外部指针引用,例如字符串,函数等
 * 执行声明为attribute(constructor)的C函数
 * 加载类的扩展中的方法
 * C++静态对象加载,调用Objc的+load函数
2. 程序执行
 * 	main函数
 * 执行UIApplicationMain函数
 * 创建UIApplication对象
 * 创建UIApplicationDelegate对象并复制
 * 对去配置文件info.plist,设置程序启动的一些属性
 * 创建应用程序的Main Runloop循环
 * UIApplicationDelegate对象开始处理监听事件
 * 程序启动之后,首先调用application.地点FinishLaunchingWithOptions:方法
 * 如果info.plist中配置启动的storyBoard的文件名,则加载storyboard文件
 * 如果没有配置,则根据代码创建UIWindow ->rootViewController ->显示

## 5.造成APP启动过慢,你可能想到的原因有哪些?
* 影响启动性能的因素**App启动过程中每一个步骤都会影响启动性能,但是有些部分所消耗的时间少之又少,另外有些部分根本无法避免,考虑到投入产出比,我们之类出我们可以优化的部分:main()函数之前耗时的影响因素
* 动态库(链接时不复制,程序运行时由系统到动态加载到内存,系统只加载一次,多个程序共用,节省内存.但苹果不让用自己的动态库)加载越多,启动越慢
* Objc类越多,启动越慢
* C的constructor函数越多,启动越慢
* C++静态对象越多,启动越慢
* Objc的+load越多,启动越慢.实验证明,在Objc类的数目一样多的情况下,需要加载的动态库越多,App启动就越慢.同样的,在动态库一样多的情况下,Objc的类越多,App启动也越慢.需要加载的动态库从1个上升到10个的时候,用户几乎感知不到任何分别,但从10个上升到100个的时候就会变得十分明显.同理,100个类和1000个类,可能也很难察觉的出,但1000个类和10000个类的分别就开始明显起来.同样的,尽量不要写attribute((constructor))的C函数,也尽量不要用到C++的静态对象;至于Objc的+load方法,似乎大家已经习惯不用它了.任何情况先,能用dispatch_once()来完成的,就尽量不要用到以上的方法.main()函数之后耗时的影响因素
* 执行main()函数的耗时
* 执行applicationWillFinishLaunching的耗时
* rootViewController及其childViewController的加载,view及其subviews的加载,applicationWillFinishLauching的耗时

### 优化目标
* 优化的目标由于每个App的情况有所不用,需要加载的数据量也有所不同,事实上我们无法使用一种统一的标准来衡量不同的App.
* 应该在400ms内的完成main()函数之前的加载
* 整体过程耗时不能超过20秒,否则系统会kill掉进程,App启动失败.应该把启动过程分为四个部分:
	1. 	main()函数之前
	2. main()函数之后至applicationWillFinishLaunching完成
	3. App完成所有本地数据的加载并将相应的信息展示给用户
	4. App完成所有联网数据的加载并将相应的信息展示给用户1+2一起决定了我们需要用户等待多久才能出现一个主视图,同时也是技术上可以精确测量的时长,1+2+3决定了用户视觉上的等待出现有用信息所需要的时长,1+2+3+4决定了我们需要多少时间才能让我们需要展示给用户的所有信息全部出现.淘宝的iOS客户端无疑是各部分都做的非常优秀的典型.它所承载的业务完全不比微信和手机QQ少,但几乎瞬间完成了启动,并利用缓存机制使的用户马上看到"貌似完整"的界面,然后立即又刷新了刚刚联网更新回来的信息.也就是说,无论是技术上还是视觉上,它都非常的"快".
	
	##### 优化建议:
	1. 	移除不需要用到的动态库
	2. 移除不需要用到的类,项目做久了,总有一些诡异的类像幽灵一样驱之不去,由于产品经理的思想作怪,需求变更后,有些类可能用不上去了,但却因为担心需求再变回来就没有移除掉,后来就彻底忘记要移除了.
	3. 合并功能类似的类和扩展(Category)由于Category的实现原理,和Objc的动态绑定有很强的关系,所以实际上类扩展是比较占用启动时间的.尽量合并一些扩展,会对启动有一定的优化作用.
	4. 压缩资源图片.压缩图片为什么能加快启动速度呢?因为启动的时候大大小小的图片加载个十来二十个是很正常的,图片小了,IO操作量就小了,启动当然就会快了.事实上,Xcode在编译App的时候,已经自动把需要打包到App里的资源图片压缩过一遍了.然而Xcode的压缩会相对比较保守.另一方面,我们正常的设计师由于需要符合其正常的审美需要生成的正常的PNG图片,因此图片大小是比较大的.解决各种矛盾的方法,就是找出一种相当靠谱的压缩方法.推荐TinyPNG.
	5. 优化applicationWillFinishLaunching 随着项目做的时间长了,applicationWillFinishLaunching里要处理的代码会越积越多.
	6. 优化rootViewController加载

## 6.0x8badf00d表示什么?
* 0x8badf00d:读作"ate bad food"!(把数字换成字母,是不是很像)该编码表示应用是因为发生watchdog超时而被iOS终止的.通常是应用花费太多时间而无法启动,终止或响应系统事件.
* 0xbad22222:该编码表示VoIP应用因为过于频繁重启而被终止.
* 0xdead10cc:读作"dead lock"!该代码表明应用因为在后台运行时占用系统资源,如通讯录数据库不释放而被终止.
* 0xdeadfa11:读作"dead fall"!该代码表示应用是被用户强制退出的.根据苹果文档,强制退出发生在用户长按开关按钮知道出现"滑动来关机",然后长按Home按钮.强制退出将产生包含0xdeadfa11 异常编码的崩溃日志,因为大多数强制退出是因为应用阻塞了界面.

## 7.怎么防止反编译?
* 本地数据加密:iOS应用防反编译加密技术之一:对NSUserDefaults,sqlite存储文件数据加密,保护账号和关键信息
* URL编码加密:iOS应用防反编译加密技术之二:对程序中出现的URL进行编码加密,防止URL被静态分析
* 网络传输数据加密:iOS应用防反编译加密技术之三:对客户端传输数据提供加密方案,有效防止通过网络接口的拦截获取数据
* 方法体,方法名高级混淆:iOS应用防反编译加密技术之四:对应用程序的方法名和方法体进行混淆,保证源码被逆向后无法解析代码
* 程序结构混排加密:iOS应用防反编译加密技术之五:对应用程序逻辑结构进行打乱混排,保证源码可读性降低到最低.
* 借助第三方APP加固:例如:网易云易盾

## 8.iOS应用架构
可从以下4个方面回答:

iOS应用架构谈 view层的组织和调用方案?

iOS应用架构谈 网络层设计方案?

iOS应用架构谈 动态部署方案?

iOS应用架构谈 本地持久化方案?

> ### 什么样app的架构叫好架构?
> 代码整齐,分类明确,没有common,没有core
> 
> 不用文档,或很少文档,就能让业务方上手
> 
> 思路和方法要统一,尽量不要多元
> 
> 没有横向依赖,万不得已不出现跨层访问
> 
> 对业务方该限制的地方有限制,该灵活的地方要给业务方创造灵活实现的条件
> 
> 易测试,易拓展
> 
> 保持一定量的超前性
> 
> 接口少,接口参数少
> 
> 高性能

* 第一类:精简型应用架构 
	
	这类架构的文章分析主要还是围绕MVC展开,以苹果自带UIViewController优劣为出发点,再结合主流的MVP,MVVM,MVCS等变种进行分析演变.这类的探讨重点在于M,V,C三类角色的定义以及之间的数据事件流向的规范.很多小型应用所面临的问题及其架构层面的解决方案都集中在这一类
* 第二类:综合型应用架构

	对于用户量级在千万或以上的应用来说,MVC这一层面的思考已无法应对业务疯狂增长所带来的负担.这类应用往往需要专业资深的架构师出面进行深层次的思考设计,业内不少大厂如淘宝,天猫,携程等都做过一些分享.不过到了这一层级的战斗,不光考验架构师的技术积累,更重要的是架构师对于业务的整体理解.姑且把这类架构名之为:综合型应用架构.综合型应用架构一般不会提到MVC,更多是在探讨"层"与"模块"的划分和耦合.
	
* 第三类:深度优化的综合型应用架构

	综合型应用架构是应对大规模业务增长的必经之路,一旦架构成型,后期业务膨胀会不停地打磨架构本身,产品本身对体验质量的追求会要求架构师和技术团队不停地优化架构细节.这种优化可以分为两块,第一是组件或模块划分的粒度越来越细,第二是组件模块的深度优化,比如网络层的深度优化,sqlite优化(多线程,FTS,安全等),数据加密,HotFix,Hybrid等,一些开源的第三方库已不能满足要求,需要团队自己重造轮子.这一层面的架构设计涉及面广,对架构师,团队技术人员的技术深度和业务理解能力有较高要求.

#### 可从以下方面回答:
* 核心功能SDK化
* 通讯,定位,Hybrid,数据库,登录,分享,基础库等
* 直接提供给其他BU独立App使用
* 公共业务功能组件化
* 地图,日历,城市,图片,通讯录等13个公共组件
* 减少个BUG重复开发工作量
* 性能数据指标采集
* 网络性能:网络服务成功率,平均耗时,耗时分布
* 定位:获取经纬度成功率,城市定位成功率
* 启动时间,内存,流量等指标
* 多种维度:系统,App版本,网络状况,位置等
* 网络优化
* 使用TCP长连接实现网络服务
* 根据网络状况2G/3G/4G/WIFI进行调优参数
* 根据连接/读/写/不同阶段使用重试机制
* 使用IP列表避免DNS解析失败或劫持
* 根据网络延迟选择服务端IP
* 使用ProtocolBuffer+Gzip减少Payload

## 8.说说你了解的第三方原理或底层知识?
RunTime,Runloop,block,SD原理,AFN,YYCache,GCD源码分析,JSPatch,GPUImage等等


# 以上资料由iOS开发这个提供,此资料只作为分享资料,不用于商业贩卖!
