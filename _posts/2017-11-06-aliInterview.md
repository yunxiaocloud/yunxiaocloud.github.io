---
layout: post
title: '来自阿里的iOS面试题'
subtitle: '来来来,查缺补漏啦'
date: 2017-11-06
categories: 技术
cover: 'http://bpic.588ku.com/back_pic/00/08/53/17562a43dac4e41.jpg!/fh/300/quality/90/unsharp/true/compress/true'
tags: iOS 安卓 客户端
---
## 寄语
#### 很多时候,我们看待技术的方向总是以目前所处的环境,或者项目.但我们应该意识到,我们是以开发者自居,而不是某某公司的开发者自居.我们学习的储备技术应该从自身出发.让自己技术范畴的选择更加宽阔,而不是随着经验的累计反而变得更加狭隘,缺少了创造性和选择性.我们是独一无二的,我们应该做独一无二的事!用全力以赴的态度去追逐,你会发现那些曾经你偷偷设想的事正一步一步朝你走来.人最珍贵的就是我们的思想,去开拓的思考,像守护生命一样,守护你坚守的梦想.

# 阿里iOS面试题
1. dSYM你是如何分析的?
2. 多线程有哪几种?你更倾向与哪一种?
3. 单例弊端?
4. 介绍下App启动的完成过程?
5. 比如App启动过慢,你可能想到的因素有哪些?
6. 0x8badfood表示是什么?
7. 怎么防止反编译?
8. 说说你了解的第三方原理或底层知识

### 1.dSYM你是如何分析的?
### dSYM是什么?
Xcode编译项目后,我们会看到一个同名的dSYM文件,dSYM是保存16进制函数地址映射信息的中转文件,我们调试的symbols都会包含在这个文件中,并且每次编译项目的时候都会生成一个新的dSYM文件,位于/Users/<用户名>/Library/Developer/Xcode/Archives目录下,对于每一个发布版本我们都很有必要保存对应的Archives文件.
### dSYM文件有什么用?
当我们软件release模式打包或上线后,不会像我们在Xcode中那样直观的看到崩溃的错误,这是时候我们就需要分析crash report文件,iOS设备中会有日志文件保存我们每个应用出错的函数内存地址,通过Xcode 的Organizer可以将iOS设备中的DeviceLog导出成crash文件,这个时候我们就可以通过出错的函数地址去查询dSYM文件中程序对应的函数名和文件名.大前提是我们需要有软件版本对应的dSYM文件,这也是为什么我们很有必要保存每个发布版本的Archives文件了.
### 如何将文件--对应?
每一个xx.app和xx.app.dSYM文件都有对应的UUID,crash文件也有自己的UUID,只要这三个文件的UUID一致,我们就可以通过解析出正确的错误函数信息了. 1.查看xx.app文件的UUID,termianl输入命令:dwarfdump --uuid xx.app/xx(xx代表你的项目名) 2.查看xx.app.dSYM文件的UUID,在termainal输入命名: dwarfdump --uuid xx.app.dSYM 3.crash 文件内第一行 Incident Identifier 就是该crash 文件的UUID.

### dSYM 工具
### 将命令封装到应用,在解决bug上提供了便利
使用步骤:1.将打包发布软件时的xcarchive文件拖入软件窗口内的任意位置(支持多个文件同时拖入,注意: 文件名不要包含空格)2.选中任意一个版本的xcarchive文件,右边会列出该xcarchive文件支持的CPU类型,选中错误对应的CPU类型. 3.对比错误给出的UUID和工具界面中给出的UUID是否一致. 4.将错误地址输入工具的文本框中,点击分析.

## 2.多线程有哪几种?你更倾向哪一种?
### 1.多线程分类
* pthread
 1. 一套通用的多线程API   
 2. 适用于Unix\Linux\Windows等系统 
 3. 跨平台.可移植
 4. 使用难度大
 5. 使用语言:C语言
 6. 使用频率:几乎不适用
 7. 线程生命周期:由开发者进行管理
* NSThread
 1. 面向对象
 2. 简单易用,可直接操作线程
 3. 使用语言:OC语言
 4. 使用频率:偶尔使用
 5. 线程生命周期: 有开发者管理
* GCD
 1. 替换NSThread等线程技术
 2. 充分利用率设备多核(自动)
 3. 使用语言: C语言
 4. 使用频率: 经常使用
 5. 线程生命周期: 自动管理
* NSOperation
 1. 基于GCD(底层是GCD)
 2. 比GCD多了一些更简单使用的功能
 3. 使用更加面向对象
 4. 使用语言:OC语言
 5. 使用频率:经常使用
 6. 线程生命周期: 自动管理

#### 多线程原理:
同一时间,CPU只能处理1条线程,只有1条线程在工作(执行)多线程并发(同时)执行,其实是CPU快速的在多条线程之前调度(切换)如果CPU调度线程的时间足够快,就造成了多线程并发执行的假象.思考:如果线程非常非常多,会发生什么情况?CPU会在N多线程之间调度,CPU会累死,消耗大量的CPU资源每条线程别调度执行的频次会降低(线程执行效率降低)

#### 多线程的优点:
能适当提高程序的执行效率,能适当提高资源利用率(CPU,内存利用率)

#### 多线程的缺点:
线程需要占用一定的内存空间(默认情况下,主线程占用1M,子线程占用512KB),如果开启大量的线程,会占用大量的内存空间,降低程序的性能,线程越多,CPU在调度线程上的开销就越大.程序设计更加复杂:比如线程之间的通信、多线程的数据共享.

### 2.你更倾向于哪一种? 倾向于GCD
GCD技术是一个轻量的,底层实现隐藏的神奇技术,我们能够通过GCD和block轻松实现多线程编程,有时候,GCD相比其他系统提供的多线程方法更加有效,当然,有时候GCD不是最佳选择,另一个多线程编程的技术NSOpreationQueue让我们能够将后台线程以队列方式依序执行,并提供更多操作的入口,这和GCD的实现有些类似.这种类似不是一个巧合,在早期,MacOS与iOS的程序都普遍采用Operation Queue 来进行编写后天线程代码,而之后出现的GCD技术大体是依照前者的原则来实现的,而随着GCD的普及,在iOS 4与MacOSX 10.6以后,Operation Queue的底层实现都是用GCD来实现的

### 那这两者之间有什么区别呢?
1. GCD是底层的C语言构成的API,而NSOperationQueue及相关对象是Objc的对象.在GCD中,在队列中执行的是由block构成的任务,这是一个轻量级的数据结构;而Operation作为一个对象,为我们提供了更多的选择
2. 在NSOperationQueue中,我们可以随时取消已经设定要准备执行的任务(当然,已经开始任务就无法阻止了),而GCD没法停止已经加入queue的block(其实是有的,但需要许多复杂的代码)
3. NSOperation能够方便的设置依赖关系,我们可以让一个Operation依赖于另一个Operation,这样的话尽管两个Operation处于同一个并行队列中,但前者会直到后者执行完毕后再执行.
4. 我们能将KVO应用在NSOperation中,可以监听一个Operation是否完成或取消,这样子能比GCD更加有效的掌控我们执行的后台任务.
5. 在NSOperation中,我们能够设置NSOperation的priority优先级,能够使同一个并行队列中任务区分先后的执行,而在GCD中,我们只能区分不同任务队列的优先级,也需要大量的复杂代码.
6. 我们能够对NSOperation进行继承,在这之上添加成语变量与成员方法,提高整个代码的复用度,这比简单的将block任务排入执行队列更有自由度,能够在其之上添加更多自定制的功能.总的来说,Operation queue提供了更多你在编写多线程程序是需要的功能,并隐藏了许多线程调度,线程取消与线程优先级的复杂代码,为我们提供简单的API入口.从编程原则来说,一般我们需要尽可能的使用高等级,封装完美的API,在必须时才使用底层API.但是我认为当我们的需求能够以更简单的底层代码完成的时候,简洁的GCD或许是个更好的选择,而Operation queue 为我们提供更多的选择.

### 3.你更倾向于哪一种? 倾向于NSOperation
1. NSOperation拥有更多的函数可用,具体查看api. NSOperationQueue是在GCD基础上实现的,只不过是GCD更高一层的抽象.
2. 在NSOperationQueue中,可以建立各个NSOperation之间的依赖关系.
3. NSOperationQueue支持KVO.可以监测Operation是否正在执行(isExecuted)、是否结束(isFinished)、是否取消(isCanceled)
4. GCD只支持FIFO的队列,而NSOperationQueue可以调整对垒的执行顺序(通过调整权重).NSOperationQueue可以方便的管理并发,NSOperation之间的优先级.使用NSOperation的情况:各个操作之间有依赖关系,操作需要取消,暂停,并发管理,控制操作之间优先级,限制同时能执行的线程数量.让线程在某时刻停止/继续等.  使用GCD的情况: 一般的需求很简单的多线程操作,用GCD就可以了,简单高效.从编程原则来说,一般我们需要尽可能的使用高等级,封装完美的API,在必须时才使用底层API.当需求简单,简洁的GCD或许是个更好的选择,而Operation queue为我们提供更多的选择.


